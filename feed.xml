<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://www.rehlers.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://www.rehlers.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-05T15:56:28+00:00</updated><id>https://www.rehlers.com/feed.xml</id><title type="html">blank</title><subtitle>A physicist exploring and quantifying the building blocks of the world. </subtitle><entry><title type="html">A first exercise with jet finding code</title><link href="https://www.rehlers.com/posts/2024/introduction-to-jet-finding/" rel="alternate" type="text/html" title="A first exercise with jet finding code"/><published>2024-02-27T09:10:00+00:00</published><updated>2024-02-27T09:10:00+00:00</updated><id>https://www.rehlers.com/posts/2024/introduction-to-jet-finding</id><content type="html" xml:base="https://www.rehlers.com/posts/2024/introduction-to-jet-finding/"><![CDATA[<p>As an introduction to physics analysis, we’ll start with a straightforward analysis: generating some simulated events, finding jets in those simulated events, and then recording some properties (eg. here, the jet spectra). We’ll generate events with <a href="https://pythia.org/">PYTHIA 8</a> and find the jets using <a href="https://fastjet.fr/">FastJet</a>.</p> <p>Below, I’ve prepared an exercise to get started, including inline questions to consider as you’re filling in the code. A few things to keep in mind:</p> <ul> <li><a href="https://pythia.org/download/pdf/worksheet8200.pdf">This Pythia 8 worksheet</a>, examples in the pythia source code, and the <a href="https://fastjet.fr/repo/fastjet-doc-3.4.2.pdf">fastjet manual</a> are excellent resources for helping to think about these questions.</li> <li>As you work, make sure you keep the overall structure in mind - it’s a common pattern for analysis code.</li> <li>Note that some reasonable physics parameters are embedded in the setup functions. These are a good starting point, but be certain to look into each parameter in the documentation to get a sense of what each one means.</li> </ul> <p>To get started,</p> <ol> <li>Make sure to <a href="/posts/2024/minimal-software-setup/">setup your software environment</a></li> <li>Create a new work directory, and create a virtual environment inside of it.</li> <li>Load the newly created virtualenv</li> <li>Install the dependencies, pythia8mc and fastjet: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>.venv<span class="o">)</span> <span class="nv">$ </span>python <span class="nt">-m</span> pip <span class="nb">install </span>pythia8mc fastjet
</code></pre></div> </div> </li> <li>Develop the code, starting from the code below</li> <li>When ready to run it, execute it with: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>.venv<span class="o">)</span> <span class="nv">$ </span>python your_filename.py
</code></pre></div> </div> </li> </ol> <p>The code is below, with some post-coding questions after the listing below.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
</pre></td><td class="code"><pre><span class="sh">"""</span><span class="s"> First jet finding exercise, running pythia with jet finding.

.. codeauthor:: Raymond Ehlers &lt;raymond.ehlers@cern.ch&gt;, LBL/UCB
.. codeauthor:: ... # Fill in your name here!
</span><span class="sh">"""</span>

<span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="n">fastjet</span> <span class="k">as</span> <span class="n">fj</span>  <span class="c1"># pyright: ignore[reportMissingImports]
</span>
<span class="c1"># NOTE: This would be just pythia8 if you compile it yourself. However, it's pythia8mc if you install via PyPI (ie. pip)
</span><span class="kn">import</span> <span class="n">pythia8mc</span>  <span class="c1"># pyright: ignore[reportMissingImports]
</span>

<span class="k">def</span> <span class="nf">setup_pythia</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">pythia8mc</span><span class="p">.</span><span class="n">Pythia</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Setup pythia to generate events.

    Note:
        This represents the minimal configuration. Later, we may customize this further.

    Returns:
        pythia: The pythia object which can be used to generate events.
    </span><span class="sh">"""</span>
    <span class="n">pythia</span> <span class="o">=</span> <span class="n">pythia8mc</span><span class="p">.</span><span class="nc">Pythia</span><span class="p">()</span>

    <span class="c1"># Parameters (you could make these function arguments)
</span>    <span class="c1"># Beam particles
</span>    <span class="c1"># **Q**: What does 2212 correspond to? (Hint: Check the Particle Data Group)
</span>    <span class="n">beam_A</span> <span class="o">=</span> <span class="mi">2212</span>
    <span class="n">beam_B</span> <span class="o">=</span> <span class="mi">2212</span>
    <span class="c1"># Center of mass energy
</span>    <span class="n">sqrt_s</span> <span class="o">=</span> <span class="mi">14000</span>
    <span class="c1"># Momentum transfer range (ie. pt hat range)
</span>    <span class="n">pt_hat_min</span><span class="p">,</span> <span class="n">pt_hat_max</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">120</span>

    <span class="c1"># Initial the pythia settings
</span>    <span class="c1"># General
</span>    <span class="n">pythia</span><span class="p">.</span><span class="nf">readString</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Beams:idA = </span><span class="si">{</span><span class="n">beam_A</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">pythia</span><span class="p">.</span><span class="nf">readString</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Beams:idB = </span><span class="si">{</span><span class="n">beam_B</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">pythia</span><span class="p">.</span><span class="nf">readString</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Beams:eCM = </span><span class="si">{</span><span class="n">sqrt_s</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>
    <span class="c1"># Provide a unique seed for each run to ensure the outputs for multiple runs or processes are not the same.
</span>    <span class="c1"># **Q**: How can you do this properly?
</span>    <span class="c1"># Check the documentation for what is valid!
</span>    <span class="n">random_seed</span> <span class="o">=</span> <span class="bp">...</span>
    <span class="n">pythia</span><span class="p">.</span><span class="nf">readString</span><span class="p">(</span><span class="sh">"</span><span class="s">Random:setSeed = on</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">pythia</span><span class="p">.</span><span class="nf">readString</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Random:seed = </span><span class="si">{</span><span class="n">random_seed</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Setup the physics processes
</span>    <span class="c1"># Enable all hard momentum transfer QCD processes.
</span>    <span class="c1"># **Q**: What does this mean? You don't need to have a precise answer, but it's good to have a general sense.
</span>    <span class="n">pythia</span><span class="p">.</span><span class="nf">readString</span><span class="p">(</span><span class="sh">"</span><span class="s">HardQCD:all = on</span><span class="sh">"</span><span class="p">)</span>
    <span class="c1"># Set the momentum transfer range
</span>    <span class="c1"># **Q**: What would we see if we didn't set this range? (Hint: Think about the cross section at increasing energy)
</span>    <span class="n">pythia</span><span class="p">.</span><span class="nf">readString</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">PhaseSpace:pTHatMin = </span><span class="si">{</span><span class="n">pt_hat_min</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">pythia</span><span class="p">.</span><span class="nf">readString</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">PhaseSpace:pTHatMax = </span><span class="si">{</span><span class="n">pt_hat_max</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pythia</span>


<span class="k">def</span> <span class="nf">setup_jet_finding_settings</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">fj</span><span class="p">.</span><span class="n">JetDefinition</span><span class="p">,</span> <span class="n">fj</span><span class="p">.</span><span class="n">AreaDefinition</span><span class="p">,</span> <span class="n">fj</span><span class="p">.</span><span class="n">Selector</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">Setup the jet finder.

    Use the following settings to get started:
    - R = 0.4
    - anti-kt jet clustering algorithm
    - Recombination scheme: E recombination scheme
    - Strategy: the fastjet::Best strategy (or just the default)
    - Area type: active_area

    Returns:
        jet_definition, area_definition: The jet definition and the area definition.
    </span><span class="sh">"""</span>
    <span class="c1"># Define base parameters. Could make these arguments
</span>    <span class="n">jet_R</span> <span class="o">=</span> <span class="mf">0.4</span>
    <span class="n">clustering_algorithm</span> <span class="o">=</span> <span class="bp">...</span>
    <span class="c1"># ...
</span>
    <span class="c1"># Create the derived fastjet settings
</span>    <span class="n">jet_definition</span> <span class="o">=</span> <span class="bp">...</span>
    <span class="n">area_definition</span> <span class="o">=</span> <span class="bp">...</span>

    <span class="k">return</span> <span class="n">jet_definition</span><span class="p">,</span> <span class="n">area_definition</span>


<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">n_events</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Run pythia and find jets.

    Args:
        n_events: Number of pythia events to generate.
    </span><span class="sh">"""</span>
    <span class="c1"># First, we need to setup pythia
</span>    <span class="n">pythia</span> <span class="o">=</span> <span class="nf">setup_pythia</span><span class="p">()</span>

    <span class="c1"># Setup your jet finder.
</span>    <span class="c1"># NOTE: If you can, you may want to move this out of the event loop. It depends on
</span>    <span class="c1">#       exactly how the package was coded up.
</span>    <span class="n">jet_definition</span><span class="p">,</span> <span class="n">area_definition</span> <span class="o">=</span> <span class="nf">setup_jet_finding_settings</span><span class="p">()</span>

    <span class="c1"># Define some objects to store the results. Usually, we do this via histograms
</span>    <span class="c1"># This can be via the ROOT package (you'll have to set it up separately)
</span>    <span class="c1"># or via the `hist` package (scikit-hep/hist on GitHub, installable via pip).
</span>    <span class="n">hist_jet_pt</span> <span class="o">=</span> <span class="bp">...</span>

    <span class="c1"># We'll run our analysis code inside of the event loop.
</span>    <span class="k">for</span> <span class="n">i_event</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_events</span><span class="p">):</span>
        <span class="n">pythia</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Generating event </span><span class="si">{</span><span class="n">i_event</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

        <span class="n">fj_particles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pythia_particle</span> <span class="ow">in</span> <span class="n">pythia</span><span class="p">.</span><span class="n">event</span><span class="p">:</span>  <span class="c1"># noqa: B007
</span>            <span class="c1"># Add some selections to the pythia particles:
</span>            <span class="c1"># - Only keep stable ("final state") particles.
</span>            <span class="c1"># - Require that that particle "is visible" (ie. interacts via the EM or strong force)
</span>            <span class="c1"># - Only select mid-rapidity particles, which we'll define as |eta| &lt; 2
</span>            <span class="c1"># - Accept all particles in phi
</span>            <span class="c1"># **Q**: How would you implement these selections? Hint: See the PYTHIA documentation
</span>            <span class="bp">...</span>

            <span class="c1"># For all particles you keep, you should convert them into a suitable type for fastjet.
</span>            <span class="c1"># This means you need to convert them into a PseudoJet. You can store them in the `fj_particles` list.
</span>
        <span class="c1"># Create the jet finder, known as the `Clustering Sequence`
</span>        <span class="c1"># **Q**: What do all of the arguments mean here? You don't need to understand in great detail,
</span>        <span class="c1">#           but it's good to have a general idea.
</span>        <span class="n">cluster_sequence</span> <span class="o">=</span> <span class="bp">...</span>

        <span class="c1"># Apply some selections to the jets
</span>        <span class="c1"># - Remove jets with pt &lt; 10 GeV
</span>        <span class="c1"># - Ensure the jets are fully contained within the "fiducial acceptance" that we've defined,
</span>        <span class="c1">#   which means that the jet must be within |eta| &lt; (2.0 - R).
</span>        <span class="c1"># **Q**: How would you implement these selections? Hint: See the fastjet documentation
</span>        <span class="c1"># Advanced **Q**: Why do we want the jet to be fully contained within our acceptance?
</span>        <span class="n">jets</span> <span class="o">=</span> <span class="bp">...</span>

        <span class="c1"># Once you have the jets, you can fill them into a histogram.
</span>        <span class="c1"># As a first example, we can fill the jet pt (which you defined above)
</span>        <span class="c1"># NOTE: This is not especially efficient in python, but it's a good starting point.
</span>        <span class="c1">#       The most efficiency approach would be via array-wise operations as done in
</span>        <span class="c1">#       eg. numpy, but that's a more advanced topic for another time.
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jets</span><span class="p">:</span>
            <span class="n">hist_jet_pt</span><span class="p">.</span><span class="nf">fill</span><span class="p">(</span><span class="n">j</span><span class="p">.</span><span class="nf">pt</span><span class="p">())</span>

        <span class="c1"># Other analysis code on the jets could go here.
</span>
    <span class="c1"># Since we generated in pt hat bins, our jets occur too often (eg. they're much more likely than
</span>    <span class="c1"># the physical cross-section). Fortunately, we can correct for this by using the pythia scaling information:
</span>    <span class="c1"># We need to rescale the histograms by the generated cross-section (sigmaGen) over the sum of the weights
</span>    <span class="c1"># used in generating the events (weightSum). ie. scale_factor = sigmaGen / weightSum
</span>    <span class="c1"># Hint: See the Pythia::Info object
</span>    <span class="n">sigma_gen</span> <span class="o">=</span> <span class="bp">...</span>
    <span class="n">weight_sum</span> <span class="o">=</span> <span class="bp">...</span>
    <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">sigma_gen</span> <span class="o">/</span> <span class="n">weight_sum</span>
    <span class="c1"># Apply this scale factor to your histogram.
</span>    <span class="c1"># You might also consider saving the unscaled and scaled versions to visually see how different they are.
</span>    <span class="c1"># **Q**: What does the size of this number suggest about how rare the process is?
</span>
    <span class="c1"># Once the event loop is done, you can save the histograms to a file.
</span>    <span class="c1"># This can be done via the `uproot` package (scikit-hep/uproot on GitHub, installable via pip).
</span>    <span class="c1"># This will write the histograms themselves to a `.root` file, which can be read via uproot or via ROOT itself.
</span>    <span class="p">...</span>  <span class="c1"># noqa: PIE790
</span>
    <span class="c1"># And now we're all done! Often, we'll print the statistics from the generation
</span>    <span class="n">pythia</span><span class="p">.</span><span class="nf">stat</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">All done!</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Since you've completed the generation, you can now go on to plotting the histograms.
</span>    <span class="c1"># Do this as your next step, in a separate script.
</span>    <span class="c1"># There are many ways to do that. One simple way is via `scikit-hep/hist` or `scikit-hep/mplhep`.
</span>    <span class="c1"># Another option is via ROOT, if you're familiar with it.
</span>    <span class="c1"># Always remember to label your figures!
</span>    <span class="c1"># **Q**: What is the most appropriate way to represent the data in the histogram?
</span>    <span class="c1">#   Hint: is it exponential? power law? Could scaling or transforming the axis make it easier to interpret?
</span>    <span class="c1"># **Q**: What is the relevant label for the y-axis?
</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">run</span><span class="p">(</span><span class="n">n_events</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>A few final questions for your consideration:</p> <ul> <li>Can you improve the existing code structure? What about command line arguments? Making it more configurable? What else could you do?</li> <li>If you were to generalize this to other analyses, how would you design and modify the code?</li> <li>proton-proton collisions are cleaner than heavy-ion collisions, which means this simulation doesn’t include all of the relevant physics (it wasn’t intended to). If we wanted to make this analysis more realistic, how might we do that? If the true physics is too complicated to simulate, could we instead add a simple toy model to recreate some of the overall properties?</li> <li>For example, what if we used a thermal model with some temperature, T? How would we relate this to heavy-ion physics? What would such a model do to our jet spectra?</li> </ul>]]></content><author><name></name></author><category term="physics"/><category term="software"/><category term="new-students"/><category term="software"/><summary type="html"><![CDATA[A gentle introduction to physics software]]></summary></entry><entry><title type="html">Quick notes on setting up your software environment</title><link href="https://www.rehlers.com/posts/2024/minimal-software-setup/" rel="alternate" type="text/html" title="Quick notes on setting up your software environment"/><published>2024-02-27T09:05:00+00:00</published><updated>2024-02-27T09:05:00+00:00</updated><id>https://www.rehlers.com/posts/2024/minimal-software-setup</id><content type="html" xml:base="https://www.rehlers.com/posts/2024/minimal-software-setup/"><![CDATA[<p>Physics is very much about investigations of the physics world, utilizing existing theory as well as our best new ideas to try to make sense of what we observe. In order to do any of that, we spend significant time writing code and working with software development tools. Below is an quick overview and summary of what we use, and how you can set it up for yourself.</p> <p>Analyzing physics data and simulations requires writing code, integrating existing libraries with new algorithms and ideas. In heavy-ion physics, this is usually done with a mix of c++ and python (and sometimes even a bit of fortran :smile:). c++ has been our preferred language, especially when performance is critical, and python has risen in recent years since it allows for rapid development and testing of ideas.</p> <p>My preferred mix is to use python as a higher level language to configure analyses, quickly implement new observables, and glue everything together. When improved performance or c++ libraries are required, we can drop down to c++, passing information back and forth using. eg <a href="https://github.com/pybind/pybind11">pybind11</a> or others.</p> <h2 id="hep-software">HEP software</h2> <p>This is substantial overlap between the tools used by high-energy physics (HEP) and heavy-ion physics. There is excellent training on many topics from the <a href="https://hepsoftwarefoundation.org/training/center.html">HEP software foundation</a>, from using a shell through physics analysis tools. This is a great place to start.</p> <p>Note that a lot of existing codes rely heavily on the <a href="https://root.cern/">ROOT</a> framework, which is developed in c++, but also has python bindings (ie. you can use it in python, if setup appropriately). I have found other tools to be more effective for my work, especially based around python and packages developed by the <a href="https://github.com/scikit-hep/">scikit-hep project</a>. Nonetheless, I still use it from time-to-time, and it’s worth understanding at at least a basic level since it’s impact is so expansive - eg. it’s file format is how we store petabytes of data from experiments!</p> <h2 id="python">Python</h2> <p>Python can be <a href="https://xkcd.com/353">very useful</a>, but it can be tricky to get it <a href="https://xkcd.com/1987">setup well</a>. A quick summary of my usual habits is:</p> <ul> <li>Always use a virtual environment! (often called a “venv” or “virtualenv”)</li> <li>Use a separate virtual environment per project.</li> </ul> <p>For actually setting up python, others have covered this better than I could, so some resources are below. They include both instructions and recommendations. Note that these articles are quite opinionated and I haven’t used them independently to set things up <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, so I don’t agree with every single thing stated, but it’s a great starting point!</p> <ul> <li><a href="https://www.bitecode.dev/p/installing-python-the-bare-minimum">Installing python</a></li> <li><a href="https://www.bitecode.dev/p/back-to-basics-with-pip-and-venv">Recommendations on how to use virtual environments</a></li> <li><a href="https://www.bitecode.dev/p/relieving-your-python-packaging-pain">A higher level overview + recommendations</a>. This is a bit more detailed, but provides intuition for a consistent workflow.</li> </ul> <h2 id="c">c++</h2> <p>Setting up a c++ compiler often is a bit more uniform since we can usually be less picky about the precise compiler version. For macOS, install the XCode command line tools, which will provide <code class="language-plaintext highlighter-rouge">cling</code>. On linux or WSL, install a recent version of <code class="language-plaintext highlighter-rouge">g++</code>.</p> <p>We use at least c++17 (or newer).</p> <hr/> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Personally, I use a tool called <a href="https://github.com/pyenv/pyenv"><code class="language-plaintext highlighter-rouge">pyenv</code></a> to install and manage my python installations on macOS and linux. However, it can be quick tricky to use, so I wouldn’t recommend it if you don’t already have experience with it. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="physics"/><category term="software"/><category term="new-students"/><category term="software"/><summary type="html"><![CDATA[Minimal notes and resources to help get started]]></summary></entry></feed>